let red := true;
let black := false;

class TreeNode {
    let info;
    let color;
    let left;
    let right;
}

fn _isRed(let tree) {
    if (tree == nil) {
        return false;
    }
    return (tree.color == red);
}

fn _rotateLeft(let h) {
    let x := h.right; 
    h.right := x.left; 
    x.left := h;
    x.color := h.color;
    h.color := red;
    return x;
}

fn _rotateRight(let h) {
    let x := h.left;
    h.left := x.right;
    x.right := h;
    x.color := h.color;
    h.color := red;
    return x;
}

fn _colorFlip(let tree) {
    println "CF";
    tree.color := true;
    tree.left.color := false;
    tree.right.color := false;
    return tree;
}

fn _leftCase(let tree) {
    if (_isRed(tree.left.right)) {
        tree.left := _rotateLeft(tree.left);
    }
    if (_isRed(tree.left.left)) {
        tree := _rotateRight(tree);
    }
    return tree;
}

fn _rightCase(let tree) {
    if (_isRed(tree.right.left)) {
        tree.right := _rotateRight(tree.right);
    }
    if (_isRed(tree.right.right)) {
        tree := _rotateLeft(tree); 
    }
    return tree;
}

fn _fixIns(let tree) {
    if (_isRed(tree.left) && _isRed(tree.right)) {
        tree := _colorFlip(tree);
    }
    if (_isRed(tree.left)) {
        tree := _leftCase(tree);
    }
    if (_isRed(tree.right)) {
        tree := _rightCase(tree);
    }
    return tree;
}

fn _putRB(let tree, let key, let cmp) {
    if (tree == nil) {
        tree := new TreeNode(true, key);
        return tree;
    }
    if (cmp(key, tree.info)) {
        tree.left := _putRB(tree.left, key, cmp);
    } else {
        tree.right := _putRB(tree.right, key, cmp);
    }
    return _fixIns(tree);
} 

fn _rbpreorder(let xs) {
    if (xs != nil) {
        print xs.info + " ";
        _rbpreorder(xs.left);
        _rbpreorder(xs.right);
    }
}

fn _rbinorder(let xs) {
    if (xs != nil) {
        _rbinorder(xs.left);
        print xs.info + " ";
        _rbinorder(xs.right);
    }
}

fn _validate(let xs, let bb) {
    if (xs == nil) {
        return bb == 0;
    }
    if (!_isRed(xs)) {
        bb--;
    }
    if (_isRed(xs) && _isRed(xs.left)) {
        println "LDR";
        return false;
    }
    if (_isRed(xs) && _isRed(xs.right)) {
        println "RDR";
        return false;
    }
    return _validate(xs.left, bb) && _validate(xs.right, bb);
}

fn isRedBlack(let xs) {
    let x := xs;
    let bb := 0;
    while (x != nil) {
        if (!_isRed(x)) {
            bb++;
        }
        x := x.left;
    }
    return _validate(xs, bb);
}

fn rb_insert(let tree, let key, let cmp) {
    println "insert: " + key;
    tree := _putRB(tree, key, cmp);
    tree.color := black;
    return tree;
}

fn rb_sort(let tree) {
    _rbinorder(tree);
    println " ";
}

fn rb_print(let tree) {
    _rbpreorder(tree);
    println " ";
}

fn rb_get(let tree, let key, let cmp) {
    let x := tree;
    while (x != nil) {
        if (x.info == key) {
            return x.info;
        } 
        if (cmp(key, x.info)) {
            x := x.left;
        } else {
            x := x.right;
        }
    }
    return nil;
}